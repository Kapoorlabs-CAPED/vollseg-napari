<class 'type'>
<class 'bytes'>
<class 'str'>
+T_co
~AnyStr
~AnyStr
<class 'bytes'>
<class 'bytes'>
<class 'bytearray'>
<class 'str'>
<class 'str'>
<class 'str'>
<class 'NoneType'>
<class 'str'>
<class 'str'>
<class 'str'>
typing.List
<class 'typing.TextIO'>
<class 'typing.TextIO'>
typing.Callable[[typing.TextIO], typing.TextIO]
typing.Callable[[typing.TextIO], typing.TextIO]
<class 'NoneType'>
<class 'typing.BinaryIO'>
<class 'typing.BinaryIO'>
<class 'NoneType'>
<class 'bool'>
<class 'typing.IO'>
<class 'bool'>
typing.Union[typing.BinaryIO, NoneType]
<class 'typing.IO'>
<class 'str'>
<class 'os.PathLike'>
<class 'int'>
<class 'typing.IO'>
<class 'bool'>
<class 'typing.IO'>
<class 'typing.IO'>
<class 'NoneType'>
<class 'bool'>
<class 'bool'>
<class 'NoneType'>
<class 'typing.TextIO'>
<class 'typing.TextIO'>
<class 'NoneType'>
<class 'typing.TextIO'>
<class 'typing.BinaryIO'>
<class 'str'>
typing.Callable[[], typing.BinaryIO]
<class 'typing.TextIO'>
typing.Union[str, NoneType]
typing.Union[str, NoneType]
<class 'str'>
typing.Callable[[typing.Union[str, NoneType], typing.Union[str, NoneType]], typing.TextIO]
Context
ForwardRef('Context')
<class 'NoneType'>
typing.Any
typing.Callable[..., typing.Any]
~AnyStr
typing.Any
typing.Any
<class 'NoneType'>
<class 'str'>
<class 'str'>
<class 'bytes'>
<class 'os.PathLike'>
<class 'str'>
typing.Sequence[str]
<class 'str'>
typing.Union[typing.Sequence[str], str]
typing.Union[typing.Sequence[str], str]
<class 'NoneType'>
Parameter
ForwardRef('Parameter')
<class 'NoneType'>
typing.Sequence[str]
typing.Sequence[str]
<class 'NoneType'>
<class 'bool'>
<class 'int'>
typing.Union[str, NoneType]
<class 'str'>
typing.Any
CompletionItem
typing.Any
typing.Any
<class 'datetime.datetime'>
<class 'datetime.datetime'>
<class 'NoneType'>
typing.Type
<class 'float'>
<class 'float'>
<class 'NoneType'>
typing.Type
typing.Type
<class 'NoneType'>
typing.Type
<class 'click.types.ParamType'>
typing.Union[typing.Type, click.types.ParamType]
<class 'int'>
typing.Union[str, NoneType]
<class 'str'>
typing.Sequence[typing.Union[str, NoneType]]
None
typing.Union[str, typing.Sequence[typing.Union[str, NoneType]], NoneType]
typing.Sequence[typing.Union[str, typing.Sequence[typing.Union[str, NoneType]], NoneType]]
typing.List[str]
<class 'str'>
<class 'str'>
typing.Union[str, NoneType]
typing.Sequence[typing.Union[str, NoneType]]
CoreParameter
typing.Dict[str, typing.Any]
typing.List[str]
typing.List[ForwardRef('CoreParameter')]
<class 'int'>
<class 'int'>
<class 'NoneType'>
typing.Tuple[str, str]
<class 'int'>
<class 'str'>
typing.Tuple[str, ...]
typing.Tuple[str, str]
None
<class 'str'>
<class 'bool'>
<class 'str'>
<class 'str'>
<class 'click.types.ParamType'>
<class 'click.types.ParamType'>
<class 'NoneType'>
<class 'bool'>
<class 'str'>
<class 'click.types.ParamType'>
typing.Any
typing.Union[click.types.ParamType, typing.Any]
typing.Union[click.types.ParamType, typing.Any]
<class 'NoneType'>
typing.Any
<class 'str'>
typing.Callable[[str], typing.Any]
typing.Callable[[str], typing.Any]
<class 'NoneType'>
typing.Iterable[str]
typing.Iterable[str]
typing.Callable[[], typing.Iterable[str]]
<class 'str'>
~V
typing.Iterable[~V]
typing.Iterable[~V]
<class 'NoneType'>
~V
~V
<class 'NoneType'>
typing.Union[str, NoneType]
typing.Union[~V, NoneType]
typing.Callable[[typing.Union[~V, NoneType]], typing.Union[str, NoneType]]
typing.Callable[[typing.Union[~V, NoneType]], typing.Union[str, NoneType]]
<class 'NoneType'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
typing.Tuple[int, int, int]
<class 'str'>
typing.Union[int, typing.Tuple[int, int, int], str]
typing.Union[int, typing.Tuple[int, int, int], str]
<class 'NoneType'>
~AnyStr
~AnyStr
<class 'NoneType'>
<class 'str'>
<class 'str'>
typing.Mapping[str, str]
typing.Mapping[str, str]
<class 'NoneType'>
<class 'str'>
<class 'bool'>
typing.Callable[[bool], str]
typing.Callable[[bool], str]
<class 'NoneType'>
<class 'int'>
typing.Callable[..., typing.Any]
<class 'str'>
Command
typing.Tuple[str, ForwardRef('Command')]
~V
~V
typing.Tuple[~V, ...]
Parameter
Parameter
HelpFormatter
typing.Dict[str, typing.Any]
typing.Dict[str, typing.Any]
<class 'NoneType'>
typing.List[str]
typing.List[str]
<class 'NoneType'>
typing.Callable[[str], str]
typing.Callable[[str], str]
<class 'NoneType'>
Context
~V
~V
~V
~V
<class 'NoneType'>
typing.Any
typing.Any
typing.Callable[[], typing.Any]
typing.Union[typing.Any, typing.Callable[[], typing.Any]]
typing.Union[typing.Any, typing.Callable[[], typing.Any]]
<class 'NoneType'>
Command
typing.Callable[..., typing.Any]
<enum 'ParameterSource'>
<enum 'ParameterSource'>
<class 'NoneType'>
<class 'click.core.Context'>
<class 'click.core.Context'>
<class 'click.core.Context'>
<class 'NoneType'>
typing.Callable[..., typing.Any]
typing.Callable[..., typing.Any]
<class 'NoneType'>
typing.List[ForwardRef('Parameter')]
typing.List[ForwardRef('Parameter')]
<class 'NoneType'>
Option
ForwardRef('Option')
<class 'NoneType'>
~F
~F
<class 'click.core.Command'>
<class 'click.core.Command'>
<class 'NoneType'>
typing.Union[str, NoneType]
typing.Union[click.core.Command, NoneType]
typing.List[str]
<class 'click.core.Command'>
typing.Type[click.core.Command]
typing.Type[click.core.Command]
<class 'NoneType'>
Group
<class 'type'>
typing.Type[ForwardRef('Group')]
typing.Type[type]
typing.Union[typing.Type[ForwardRef('Group')], typing.Type[type]]
typing.Union[typing.Type[ForwardRef('Group')], typing.Type[type]]
<class 'NoneType'>
<class 'str'>
<class 'click.core.Command'>
<class 'click.core.Command'>
typing.Dict[str, click.core.Command]
typing.Sequence[click.core.Command]
typing.Union[typing.Dict[str, click.core.Command], typing.Sequence[click.core.Command]]
typing.Union[typing.Dict[str, click.core.Command], typing.Sequence[click.core.Command]]
<class 'NoneType'>
<class 'click.core.Command'>
typing.Callable[..., typing.Any]
Group
typing.Callable[..., typing.Any]
<class 'click.core.MultiCommand'>
typing.List[click.core.MultiCommand]
typing.List[click.core.MultiCommand]
<class 'NoneType'>
typing.Any
typing.Any
<class 'click.core.Context'>
Parameter
typing.Any
typing.Callable[[click.core.Context, ForwardRef('Parameter'), typing.Any], typing.Any]
typing.Callable[[click.core.Context, ForwardRef('Parameter'), typing.Any], typing.Any]
<class 'NoneType'>
<class 'str'>
typing.Sequence[str]
typing.List[ForwardRef('CompletionItem')]
typing.List[str]
typing.Union[typing.List[ForwardRef('CompletionItem')], typing.List[str]]
<class 'click.core.Context'>
Parameter
<class 'str'>
typing.Callable[[click.core.Context, ForwardRef('Parameter'), str], typing.Union[typing.List[ForwardRef('CompletionItem')], typing.List[str]]]
typing.Callable[[click.core.Context, ForwardRef('Parameter'), str], typing.Union[typing.List[ForwardRef('CompletionItem')], typing.List[str]]]
<class 'NoneType'>
typing.Tuple[str, str]
<class 'str'>
typing.Union[typing.Tuple[str, str], str]
typing.List[typing.Union[typing.Tuple[str, str], str]]
<class 'click.core.Context'>
typing.List[str]
<class 'str'>
typing.Callable[[click.core.Context, typing.List[str], str], typing.List[typing.Union[typing.Tuple[str, str], str]]]
typing.Callable[[click.core.Context, typing.List[str], str], typing.List[typing.Union[typing.Tuple[str, str], str]]]
<class 'NoneType'>
typing.Union[str, NoneType]
typing.List[str]
typing.List[str]
<class 'str'>
typing.Any
typing.Any
<enum 'ParameterSource'>
typing.Any
typing.List[str]
typing.Tuple[str, str]
typing.Tuple[str, str]
<class 'NoneType'>
<class 'str'>
Parameter
typing.Callable[..., typing.Any]
typing.Callable[..., typing.Any]
<class 'click.core.Command'>
<class 'str'>
typing.Any
<class 'click.core.Command'>
~F
<class 'click.core.Group'>
~F
~FC
~FC
<class 'str'>
<class 'str'>
<class 'int'>
typing.Union[str, NoneType]
typing.Union[str, NoneType]
<class 'dotenv.parser.Original'>
<class 'bool'>
<class 'dotenv.parser.Binding'>
<class 'str'>
typing.Union[str, NoneType]
<class 'dotenv.variables.Atom'>
<class 'str'>
<class 'os.PathLike'>
typing.Union[str, os.PathLike]
typing.Union[str, os.PathLike]
<class 'NoneType'>
typing.IO[str]
typing.IO[str]
<class 'NoneType'>
None
<class 'str'>
typing.IO[str]
<class 'str'>
typing.Union[str, NoneType]
<class 'str'>
typing.Union[str, NoneType]
typing.Tuple[str, typing.Union[str, NoneType]]
typing.IO[str]
typing.IO[str]
typing.Tuple[typing.IO[str], typing.IO[str]]
typing.Union[bool, NoneType]
<class 'str'>
<class 'str'>
typing.Union[bool, NoneType]
<class 'str'>
typing.Tuple[str, typing.Union[str, NoneType]]
<class 'str'>
<class 'str'>
<class 'os.PathLike'>
None
typing.Callable[..., typing.Any]
typing.Type
<class 'pipenv.vendor.click.types.ParamType'>
typing.Union[typing.Type, pipenv.vendor.click.types.ParamType]
<class 'pipenv.vendor.click.types.ParamType'>
<class 'pipenv.vendor.click.types.ParamType'>
<class 'NoneType'>
<class 'pipenv.vendor.click.types.ParamType'>
typing.Any
typing.Union[pipenv.vendor.click.types.ParamType, typing.Any]
typing.Union[pipenv.vendor.click.types.ParamType, typing.Any]
<class 'NoneType'>
~V
typing.Iterable[~V]
typing.Iterable[~V]
<class 'NoneType'>
~V
~V
<class 'NoneType'>
typing.Union[str, NoneType]
typing.Union[~V, NoneType]
typing.Callable[[typing.Union[~V, NoneType]], typing.Union[str, NoneType]]
typing.Callable[[typing.Union[~V, NoneType]], typing.Union[str, NoneType]]
<class 'NoneType'>
typing.Callable[..., typing.Any]
~V
~V
typing.Tuple[~V, ...]
~V
~V
~V
~V
<class 'NoneType'>
<enum 'ParameterSource'>
<enum 'ParameterSource'>
<class 'NoneType'>
<class 'pipenv.vendor.click.core.Context'>
<class 'pipenv.vendor.click.core.Context'>
<class 'pipenv.vendor.click.core.Context'>
<class 'NoneType'>
~F
~F
<class 'pipenv.vendor.click.core.Command'>
<class 'pipenv.vendor.click.core.Command'>
<class 'NoneType'>
typing.Union[str, NoneType]
typing.Union[pipenv.vendor.click.core.Command, NoneType]
typing.List[str]
<class 'pipenv.vendor.click.core.Command'>
typing.Type[pipenv.vendor.click.core.Command]
typing.Type[pipenv.vendor.click.core.Command]
<class 'NoneType'>
<class 'str'>
<class 'pipenv.vendor.click.core.Command'>
<class 'pipenv.vendor.click.core.Command'>
typing.Dict[str, pipenv.vendor.click.core.Command]
typing.Sequence[pipenv.vendor.click.core.Command]
typing.Union[typing.Dict[str, pipenv.vendor.click.core.Command], typing.Sequence[pipenv.vendor.click.core.Command]]
typing.Union[typing.Dict[str, pipenv.vendor.click.core.Command], typing.Sequence[pipenv.vendor.click.core.Command]]
<class 'NoneType'>
<class 'pipenv.vendor.click.core.Command'>
typing.Callable[..., typing.Any]
<class 'pipenv.vendor.click.core.MultiCommand'>
typing.List[pipenv.vendor.click.core.MultiCommand]
typing.List[pipenv.vendor.click.core.MultiCommand]
<class 'NoneType'>
typing.Any
<class 'pipenv.vendor.click.core.Context'>
Parameter
typing.Any
typing.Callable[[pipenv.vendor.click.core.Context, ForwardRef('Parameter'), typing.Any], typing.Any]
typing.Callable[[pipenv.vendor.click.core.Context, ForwardRef('Parameter'), typing.Any], typing.Any]
<class 'NoneType'>
typing.Union[typing.List[ForwardRef('CompletionItem')], typing.List[str]]
<class 'pipenv.vendor.click.core.Context'>
Parameter
<class 'str'>
typing.Callable[[pipenv.vendor.click.core.Context, ForwardRef('Parameter'), str], typing.Union[typing.List[ForwardRef('CompletionItem')], typing.List[str]]]
typing.Callable[[pipenv.vendor.click.core.Context, ForwardRef('Parameter'), str], typing.Union[typing.List[ForwardRef('CompletionItem')], typing.List[str]]]
<class 'NoneType'>
typing.List[typing.Union[typing.Tuple[str, str], str]]
<class 'pipenv.vendor.click.core.Context'>
typing.List[str]
<class 'str'>
typing.Callable[[pipenv.vendor.click.core.Context, typing.List[str], str], typing.List[typing.Union[typing.Tuple[str, str], str]]]
typing.Callable[[pipenv.vendor.click.core.Context, typing.List[str], str], typing.List[typing.Union[typing.Tuple[str, str], str]]]
<class 'NoneType'>
typing.Any
<enum 'ParameterSource'>
typing.Callable[..., typing.Any]
typing.Callable[..., typing.Any]
<class 'pipenv.vendor.click.core.Command'>
<class 'pipenv.vendor.click.core.Command'>
~F
<class 'pipenv.vendor.click.core.Group'>
~F
~FC
~FC
<class 'pipenv.vendor.packaging._manylinux._ELFFileHeader'>
<class 'pipenv.vendor.packaging._manylinux._ELFFileHeader'>
<class 'NoneType'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'pipenv.vendor.packaging._musllinux._MuslVersion'>
<class 'pipenv.vendor.packaging._musllinux._MuslVersion'>
<class 'NoneType'>
<class 'str'>
<class 'str'>
<class 'pipenv.vendor.packaging.tags.Tag'>
<class 'int'>
<class 'str'>
None
typing.Sequence[int]
typing.Sequence[int]
<class 'NoneType'>
typing.Iterable[str]
typing.Iterable[str]
<class 'NoneType'>
<class 'pipenv.vendor.packaging.tags.Tag'>
typing.Tuple[int, int]
typing.Tuple[int, int]
<class 'NoneType'>
<class 'pipenv.vendor.packaging._structures.InfinityType'>
<class 'pipenv.vendor.packaging._structures.NegativeInfinityType'>
<class 'str'>
<class 'int'>
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType]
typing.Tuple[str, int]
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType]
<class 'int'>
<class 'str'>
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]
<class 'str'>
<class 'pipenv.vendor.packaging._structures.NegativeInfinityType'>
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]
typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str]
typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]]
<class 'pipenv.vendor.packaging._structures.NegativeInfinityType'>
typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]
<class 'int'>
typing.Tuple[int, ...]
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]
<class 'int'>
typing.Tuple[str, ...]
typing.Tuple[int, typing.Tuple[int, ...], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]]
typing.Tuple[int, typing.Tuple[str, ...]]
<class 'bool'>
typing.Union[typing.Tuple[int, typing.Tuple[int, ...], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]], typing.Tuple[int, typing.Tuple[str, ...]]]
typing.Union[typing.Tuple[int, typing.Tuple[int, ...], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]], typing.Tuple[int, typing.Tuple[str, ...]]]
LegacyVersion
Version
typing.Tuple[str, int]
typing.Tuple[str, int]
<class 'NoneType'>
<class 'str'>
<class 'bytes'>
<class 'typing.SupportsInt'>
typing.Union[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]
typing.Union[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]
<class 'NoneType'>
typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]
typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]
typing.Tuple[typing.Union[pipenv.vendor.packaging._structures.InfinityType, pipenv.vendor.packaging._structures.NegativeInfinityType, int, str]]
<class 'NoneType'>
<class 'int'>
<class 'str'>
typing.Tuple[()]
typing.Tuple[int, str]
<class 'pipenv.vendor.packaging.version.Version'>
<class 'str'>
<function NewType.<locals>.new_type at 0x7f97bbd02f28>
<class 'pipenv.vendor.packaging.version.Version'>
typing.Union[typing.Tuple[()], typing.Tuple[int, str]]
typing.FrozenSet[pipenv.vendor.packaging.tags.Tag]
<function NewType.<locals>.new_type at 0x7f97bbd02f28>
<class 'pipenv.vendor.packaging.version.Version'>
<class 'pipenv.vendor.packaging.version.Version'>
<class 'pipenv.vendor.packaging.version.LegacyVersion'>
<class 'pipenv.vendor.packaging.version.Version'>
<class 'pipenv.vendor.packaging.version.LegacyVersion'>
<class 'str'>
typing.Union[pipenv.vendor.packaging.version.Version, pipenv.vendor.packaging.version.LegacyVersion, str]
<class 'bool'>
typing.Union[pipenv.vendor.packaging.version.Version, pipenv.vendor.packaging.version.LegacyVersion]
<class 'str'>
~VersionTypeVar
<class 'bool'>
Specifier
typing.Union[pipenv.vendor.packaging.version.Version, pipenv.vendor.packaging.version.LegacyVersion]
<class 'str'>
typing.List[str]
typing.List[str]
SpecifierSet
<class 'str'>
<class 'pipenv.vendor.packaging.specifiers._IndividualSpecifier'>
<class 'bool'>
<class 'str'>
<class 'str'>
typing.Any
<class 'pipenv.vendor.pyparsing.ParseResults'>
typing.List[typing.Any]
<class 'pipenv.vendor.packaging.markers.Node'>
typing.List[str]
typing.Tuple[pipenv.vendor.packaging.markers.Node, ...]
<class 'str'>
<class 'str'>
typing.Callable[[str, str], bool]
typing.Dict[str, str]
typing.Dict[str, str]
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.packaging._manylinux._ELFFileHeader'>
<class 'pipenv.patched.notpip._vendor.packaging._manylinux._ELFFileHeader'>
<class 'NoneType'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'pipenv.patched.notpip._vendor.packaging._musllinux._MuslVersion'>
<class 'pipenv.patched.notpip._vendor.packaging._musllinux._MuslVersion'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.packaging.tags.Tag'>
<class 'pipenv.patched.notpip._vendor.packaging.tags.Tag'>
<class 'pipenv.patched.notpip._vendor.packaging._structures.InfinityType'>
<class 'pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType'>
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType]
typing.Tuple[str, int]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType]
<class 'int'>
<class 'str'>
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]
<class 'str'>
<class 'pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType'>
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]
typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str]
typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]]
<class 'pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType'>
typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]
<class 'int'>
typing.Tuple[int, ...]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]
typing.Tuple[int, typing.Tuple[int, ...], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]]
typing.Tuple[int, typing.Tuple[str, ...]]
<class 'bool'>
typing.Union[typing.Tuple[int, typing.Tuple[int, ...], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]], typing.Tuple[int, typing.Tuple[str, ...]]]
typing.Union[typing.Tuple[int, typing.Tuple[int, ...], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]], typing.Tuple[int, typing.Tuple[str, ...]]]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]], ...]]
<class 'NoneType'>
typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]
typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]
typing.Tuple[typing.Union[pipenv.patched.notpip._vendor.packaging._structures.InfinityType, pipenv.patched.notpip._vendor.packaging._structures.NegativeInfinityType, int, str]]
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.packaging.version.Version'>
<class 'str'>
<function NewType.<locals>.new_type at 0x7f97bc534950>
<class 'pipenv.patched.notpip._vendor.packaging.version.Version'>
typing.Union[typing.Tuple[()], typing.Tuple[int, str]]
typing.FrozenSet[pipenv.patched.notpip._vendor.packaging.tags.Tag]
<function NewType.<locals>.new_type at 0x7f97bc534950>
<class 'pipenv.patched.notpip._vendor.packaging.version.Version'>
<class 'pipenv.patched.notpip._vendor.packaging.version.Version'>
<class 'pipenv.patched.notpip._vendor.packaging.version.LegacyVersion'>
<class 'pipenv.patched.notpip._vendor.packaging.version.Version'>
<class 'pipenv.patched.notpip._vendor.packaging.version.LegacyVersion'>
<class 'str'>
typing.Union[pipenv.patched.notpip._vendor.packaging.version.Version, pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, str]
<class 'bool'>
typing.Union[pipenv.patched.notpip._vendor.packaging.version.Version, pipenv.patched.notpip._vendor.packaging.version.LegacyVersion]
<class 'str'>
~VersionTypeVar
<class 'bool'>
Specifier
typing.Union[pipenv.patched.notpip._vendor.packaging.version.Version, pipenv.patched.notpip._vendor.packaging.version.LegacyVersion]
<class 'str'>
<class 'pipenv.patched.notpip._vendor.packaging.specifiers._IndividualSpecifier'>
<class 'pipenv.patched.notpip._vendor.pyparsing.ParseResults'>
typing.List[typing.Any]
<class 'pipenv.patched.notpip._vendor.packaging.markers.Node'>
typing.List[str]
typing.Tuple[pipenv.patched.notpip._vendor.packaging.markers.Node, ...]
<class 'str'>
<class 'str'>
<class 'module'>
<class 'str'>
<class 'os.PathLike'>
<class 'importlib.abc.ResourceReader'>
<class 'importlib.abc.ResourceReader'>
<class 'NoneType'>
<class 'pathlib.Path'>
typing.Set[str]
typing.Set[str]
<class 'NoneType'>
<class 'str'>
<class 'bool'>
<class 'BaseException'>
<class 'BaseException'>
typing.Type[BaseException]
typing.Type[BaseException]
typing.Tuple[typing.Type[BaseException], ...]
<class 'bool'>
typing.Any
<class 'float'>
<class 'float'>
<class 'NoneType'>
wait_combine
wait_base
<class 'int'>
<class 'float'>
None
RetryCallState
typing.Callable
~WrappedFn
~WrappedFn
~WrappedFn
typing.Callable[[~WrappedFn], ~WrappedFn]
typing.Any
<class 'object'>
typing.Type[BaseException]
typing.Type[BaseException]
<class 'NoneType'>
<class 'BaseException'>
<class 'BaseException'>
<class 'NoneType'>
types.TracebackType
ForwardRef('types.TracebackType')
<class 'NoneType'>
None
typing.Union[int, float]
typing.Callable[[ForwardRef('RetryCallState')], NoneType]
typing.Callable[[ForwardRef('RetryCallState')], NoneType]
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.tenacity.RetryError'>
typing.Any
RetryCallState
typing.Callable[[ForwardRef('RetryCallState')], typing.Any]
typing.Callable[[ForwardRef('RetryCallState')], typing.Any]
<class 'NoneType'>
typing.Callable[[typing.Union[int, float]], NoneType]
<class 'object'>
stop_base
<class 'object'>
wait_base
<class 'object'>
<class 'pipenv.patched.notpip._vendor.tenacity.retry.retry_base'>
<class 'object'>
typing.Callable[[ForwardRef('RetryCallState')], NoneType]
<class 'object'>
typing.Union[typing.Callable[[ForwardRef('RetryCallState')], NoneType], NoneType]
<class 'object'>
<class 'bool'>
<class 'object'>
typing.Type[pipenv.patched.notpip._vendor.tenacity.RetryError]
<class 'object'>
typing.Union[typing.Callable[[ForwardRef('RetryCallState')], typing.Any], NoneType]
<class 'object'>
<class 'pipenv.patched.notpip._vendor.tenacity.DoAttempt'>
<class 'pipenv.patched.notpip._vendor.tenacity.DoSleep'>
typing.Any
<class 'pipenv.patched.notpip._vendor.tenacity.AttemptManager'>
None
None
~_RetValT
~WrappedFn
~WrappedFn
<class 'NoneType'>
typing.Type[BaseException]
<class 'BaseException'>
types.TracebackType
typing.Callable
typing.Awaitable
<class 'float'>
~_RetValT
typing.Awaitable[~_RetValT]
<class 'pipenv.patched.notpip._vendor.tenacity.AttemptManager'>
typing.Any
<class 'Warning'>
<class 'str'>
<class 'Warning'>
<class 'typing.TextIO'>
<class 'typing.TextIO'>
<class 'NoneType'>
<class 'str'>
typing.Type[BaseException]
<class 'BaseException'>
<class 'traceback'>
typing.Union[str, NoneType]
typing.Union[str, NoneType]
<class 'str'>
typing.Tuple[typing.Union[str, NoneType], typing.Union[str, NoneType]]
<class 'str'>
HTMLPage
typing.Union[str, ForwardRef('HTMLPage')]
typing.Union[str, ForwardRef('HTMLPage')]
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.utils.hashes.Hashes'>
<class 'pipenv.patched.notpip._internal.utils.hashes.Hashes'>
<class 'NoneType'>
<class 'str'>
typing.List[str]
<class 'urllib.parse.SplitResult'>
typing.Dict[str, typing.List[str]]
<class 'str'>
typing.Dict[str, str]
<class 'pipenv.patched.notpip._vendor.packaging.tags.Tag'>
<class 'pipenv.patched.notpip._vendor.packaging.tags.Tag'>
<class 'int'>
<class 'pipenv.patched.notpip._vendor.packaging.tags.Tag'>
TempDirectory
<class 'optparse.Option'>
<class 'str'>
typing.Any
typing.Tuple[str, typing.Any]
typing.Tuple[int, ...]
typing.Tuple[int, ...]
<class 'NoneType'>
<class 'optparse.Values'>
<class 'optparse.Values'>
<class 'NoneType'>
<class 'optparse.Option'>
typing.Tuple[int, ...]
typing.Union[str, NoneType]
+_T
<class 'typing.BinaryIO'>
typing.Any
typing.Any
~T
~T
~T
<class 'NoneType'>
InfoType
ForwardRef('InfoType')
<class 'NoneType'>
typing.Union[ForwardRef('InfoType'), NoneType]
typing.Dict[str, typing.Any]
typing.Dict[str, typing.Any]
<class 'NoneType'>
VcsInfo
ForwardRef('VcsInfo')
<class 'NoneType'>
ArchiveInfo
ForwardRef('ArchiveInfo')
<class 'NoneType'>
DirInfo
ForwardRef('DirInfo')
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.models.direct_url.ArchiveInfo'>
<class 'pipenv.patched.notpip._internal.models.direct_url.DirInfo'>
<class 'pipenv.patched.notpip._internal.models.direct_url.VcsInfo'>
<class 'pipenv.patched.notpip._vendor.packaging.version.LegacyVersion'>
<class 'pipenv.patched.notpip._vendor.packaging.version.Version'>
<class 'pipenv.patched.notpip._internal.models.direct_url.DirectUrl'>
<class 'pipenv.patched.notpip._internal.models.direct_url.DirectUrl'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.metadata.base.BaseEntryPoint'>
<class 'str'>
<class 'pipenv.patched.notpip._vendor.packaging.requirements.Requirement'>
BaseDistribution
ForwardRef('BaseDistribution')
<class 'NoneType'>
BaseDistribution
<class 'str'>
<class 'pipenv.patched.notpip._internal.metadata.base.BaseDistribution'>
<class 'pipenv.patched.notpip._internal.cli.spinners.SpinnerInterface'>
<class 'str'>
<class 'pipenv.patched.notpip._internal.utils.misc.HiddenText'>
typing.Union[str, pipenv.patched.notpip._internal.utils.misc.HiddenText]
<class 'str'>
<class 'str'>
<class 'str'>
typing.List[typing.Any]
~_T
<class 'str'>
typing.List[str]
<class 'str'>
typing.Union[str, typing.List[str]]
Distribution
ForwardRef('Distribution')
<class 'NoneType'>
<class 'importlib_metadata.EntryPoints'>
<class 'importlib_metadata.SelectableGroups'>
<class 'str'>
typing.List[str]
<class 'keyring.credentials.SimpleCredential'>
<class 'keyring.credentials.SimpleCredential'>
<class 'NoneType'>
typing.Tuple[typing.Union[str, NoneType], typing.Union[str, NoneType]]
typing.Tuple[typing.Union[str, NoneType], typing.Union[str, NoneType]]
<class 'NoneType'>
<class 'str'>
typing.Union[str, NoneType]
typing.Union[str, NoneType]
typing.Union[str, NoneType]
typing.Union[str, NoneType]
<class 'bool'>
<class 'bytes'>
<class 'bytes'>
<class 'NoneType'>
<class 'int'>
<class 'str'>
typing.Union[int, str]
typing.Union[int, str]
<class 'NoneType'>
<class 'str'>
<class 'str'>
typing.Union[int, str, NoneType]
typing.Tuple[str, str, typing.Union[int, str, NoneType]]
<class 'float'>
<class 'float'>
<class 'float'>
typing.Tuple[float, float]
typing.Union[float, typing.Tuple[float, float]]
typing.Union[float, typing.Tuple[float, float]]
<class 'NoneType'>
<class 'bool'>
<class 'str'>
<class 'str'>
typing.Tuple[str, str]
typing.Union[str, typing.Tuple[str, str]]
typing.Union[str, typing.Tuple[str, str]]
<class 'NoneType'>
typing.Mapping[str, str]
typing.Mapping[str, str]
<class 'NoneType'>
typing.Tuple[str, str, typing.Union[int, str, NoneType]]
<class 'bytes'>
<class 'pipenv.patched.notpip._internal.models.candidate.InstallationCandidate'>
<class 'pipenv.patched.notpip._internal.models.link.Link'>
typing.Iterable[pipenv.patched.notpip._internal.models.candidate.InstallationCandidate]
<class 'pipenv.patched.notpip._internal.models.link.Link'>
<class 'bool'>
<class 'pipenv.patched.notpip._internal.models.link.Link'>
<class 'pipenv.patched.notpip._internal.models.link.Link'>
<class 'pipenv.patched.notpip._internal.models.link.Link'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.index.sources.LinkSource'>
<class 'pipenv.patched.notpip._internal.index.sources.LinkSource'>
<class 'NoneType'>
typing.Union[str, NoneType]
typing.Union[pipenv.patched.notpip._internal.index.sources.LinkSource, NoneType]
<class 'str'>
<class 'str'>
typing.Iterable[pipenv.patched.notpip._internal.models.link.Link]
HTMLPage
<class 'pipenv.patched.notpip._internal.models.link.Link'>
typing.List[pipenv.patched.notpip._internal.models.link.Link]
HTMLPage
<class 'str'>
<class 'Exception'>
None
typing.Callable[..., NoneType]
typing.Callable[..., NoneType]
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.network.session.PipSession'>
<class 'pipenv.patched.notpip._internal.network.session.PipSession'>
<class 'NoneType'>
HTMLPage
ForwardRef('HTMLPage')
<class 'NoneType'>
typing.Union[pipenv.patched.notpip._internal.index.sources.LinkSource, NoneType]
typing.Sequence[typing.Union[pipenv.patched.notpip._internal.index.sources.LinkSource, NoneType]]
typing.Sequence[typing.Union[pipenv.patched.notpip._internal.index.sources.LinkSource, NoneType]]
<class 'pipenv.patched.notpip._internal.index.collector.HTMLPage'>
<class 'pipenv.patched.notpip._internal.index.collector.HTMLPage'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.models.format_control.FormatControl'>
<class 'pipenv.patched.notpip._internal.models.format_control.FormatControl'>
<class 'NoneType'>
<class 'bytes'>
<class 'str'>
typing.Tuple[bytes, str]
typing.Tuple[int, str]
<class 'str'>
<class 'optparse.Values'>
typing.Tuple[str, optparse.Values]
<class 'str'>
typing.Callable[..., optparse.Option]
PackageFinder
ForwardRef('PackageFinder')
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.req.req_file.ParsedRequirement'>
<class 'pipenv.patched.notpip._internal.req.req_file.ParsedRequirement'>
<class 'pipenv.patched.notpip._internal.req.req_file.ParsedRequirement'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.req.req_file.ParsedLine'>
<class 'datetime.datetime'>
<class 'datetime.date'>
<class 'int'>
typing.Tuple[str, ...]
typing.Any
<class 'int'>
<class 'list'>
<class 'int'>
<class 'dict'>
<class 'int'>
typing.Any
<function NewType.<locals>.new_type at 0x7f97bd114048>
<class 'str'>
typing.Union[int, str]
typing.Dict[str, str]
typing.Dict[str, str]
typing.Iterator[typing.Any]
typing.Set[str]
typing.Set[str]
<class 'pipenv.patched.notpip._vendor.packaging.requirements.Requirement'>
<class 'pipenv.patched.notpip._vendor.packaging.requirements.Requirement'>
<class 'NoneType'>
<class 'str'>
InstallRequirement
typing.Union[str, ForwardRef('InstallRequirement')]
typing.Union[str, ForwardRef('InstallRequirement')]
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.packaging.markers.Marker'>
<class 'pipenv.patched.notpip._vendor.packaging.markers.Marker'>
<class 'NoneType'>
typing.Dict[str, typing.List[str]]
typing.Dict[str, typing.List[str]]
<class 'NoneType'>
typing.Iterable[str]
typing.Iterable[str]
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.req.req_uninstall.UninstallPathSet'>
<class 'pipenv.patched.notpip._internal.req.req_uninstall.UninstallPathSet'>
<class 'NoneType'>
typing.Sequence[str]
typing.Sequence[str]
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'NoneType'>
typing.List[pipenv.patched.notpip._internal.req.req_install.InstallRequirement]
typing.Union[pipenv.patched.notpip._internal.req.req_install.InstallRequirement, NoneType]
<class 'str'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
typing.Tuple[str, pipenv.patched.notpip._internal.req.req_install.InstallRequirement]
<class 'pipenv.patched.notpip._internal.req.InstallationResult'>
typing.Tuple[()]
typing.Tuple[int, str]
<class 'int'>
<class 'int'>
<class 'int'>
<class 'pipenv.patched.notpip._vendor.packaging.version._BaseVersion'>
typing.Union[int, NoneType]
typing.Union[typing.Tuple[()], typing.Tuple[int, str]]
<class 'bool'>
typing.Union[str, NoneType]
<class 'pipenv.patched.notpip._internal.models.candidate.InstallationCandidate'>
<class 'pipenv.patched.notpip._internal.models.candidate.InstallationCandidate'>
<class 'pipenv.patched.notpip._internal.models.candidate.InstallationCandidate'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.models.target_python.TargetPython'>
<class 'pipenv.patched.notpip._internal.models.target_python.TargetPython'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.packaging.specifiers.BaseSpecifier'>
<class 'pipenv.patched.notpip._vendor.packaging.specifiers.BaseSpecifier'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._internal.index.package_finder.CandidatePreferences'>
<class 'pipenv.patched.notpip._internal.index.package_finder.CandidatePreferences'>
<class 'NoneType'>
<class 'pipenv.patched.notpip._vendor.pkg_resources.Distribution'>
<class 'pipenv.patched.notpip._vendor.pkg_resources.Distribution'>
<class 'NoneType'>
<class 'bytes'>
<class 'pipenv.patched.notpip._internal.models.link.Link'>
typing.Tuple[str, str]
typing.Tuple[pipenv.patched.notpip._internal.models.link.Link, typing.Tuple[str, str]]
typing.Tuple[int, int]
RequirementTracker
typing.Type[BaseException]
typing.Type[BaseException]
<class 'NoneType'>
<class 'BaseException'>
<class 'BaseException'>
<class 'NoneType'>
<class 'traceback'>
<class 'traceback'>
<class 'NoneType'>
typing.Union[str, NoneType]
<class 'str'>
typing.Set[str]
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'str'>
typing.Union[pipenv.patched.notpip._internal.req.req_install.InstallRequirement, str]
typing.Union[pipenv.patched.notpip._internal.req.req_install.InstallRequirement, str]
<class 'NoneType'>
<class 'str'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'str'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
<class 'pipenv.patched.notpip._internal.cache.WheelCache'>
<class 'pipenv.patched.notpip._internal.cache.WheelCache'>
<class 'NoneType'>
<class 'str'>
None
Literal[False]
<class 'pipenv.vendor.platformdirs.api.PlatformDirsABC'>
<class 'platformdirs.api.PlatformDirsABC'>
<class 'packaging._manylinux._ELFFileHeader'>
<class 'packaging._manylinux._ELFFileHeader'>
<class 'NoneType'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'int'>
<class 'packaging._musllinux._MuslVersion'>
<class 'packaging._musllinux._MuslVersion'>
<class 'NoneType'>
<class 'packaging.tags.Tag'>
<class 'int'>
<class 'str'>
None
typing.Sequence[int]
typing.Sequence[int]
<class 'NoneType'>
<class 'packaging.tags.Tag'>
typing.Tuple[int, int]
typing.Tuple[int, int]
<class 'NoneType'>
<class 'packaging._structures.InfinityType'>
<class 'packaging._structures.NegativeInfinityType'>
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType]
typing.Tuple[str, int]
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType]
<class 'int'>
<class 'str'>
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]
<class 'str'>
<class 'packaging._structures.NegativeInfinityType'>
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]
typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str]
typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]]
<class 'packaging._structures.NegativeInfinityType'>
typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]
<class 'int'>
typing.Tuple[int, ...]
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]]
typing.Union[packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]]
typing.Tuple[int, typing.Tuple[int, ...], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]]]
typing.Tuple[int, typing.Tuple[str, ...]]
<class 'bool'>
typing.Union[typing.Tuple[int, typing.Tuple[int, ...], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]]], typing.Tuple[int, typing.Tuple[str, ...]]]
typing.Union[typing.Tuple[int, typing.Tuple[int, ...], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, typing.Tuple[str, int]], typing.Union[packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]]], typing.Tuple[int, typing.Tuple[str, ...]]]
LegacyVersion
Version
typing.Tuple[str, int]
typing.Tuple[str, int]
<class 'NoneType'>
<class 'str'>
<class 'bytes'>
<class 'typing.SupportsInt'>
typing.Union[packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]]
typing.Union[packaging._structures.NegativeInfinityType, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str, typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str], str], typing.Tuple[packaging._structures.NegativeInfinityType, typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]], ...]]
<class 'NoneType'>
typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]
typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]
typing.Tuple[typing.Union[packaging._structures.InfinityType, packaging._structures.NegativeInfinityType, int, str]]
<class 'NoneType'>
<class 'packaging.version.Version'>
<class 'str'>
<function NewType.<locals>.new_type at 0x7f97bd2ab9d8>
<class 'packaging.version.Version'>
typing.Union[typing.Tuple[()], typing.Tuple[int, str]]
typing.FrozenSet[packaging.tags.Tag]
<function NewType.<locals>.new_type at 0x7f97bd2ab9d8>
<class 'packaging.version.Version'>
<class 'packaging.version.Version'>
<class 'packaging.version.LegacyVersion'>
<class 'packaging.version.Version'>
<class 'packaging.version.LegacyVersion'>
<class 'str'>
typing.Union[packaging.version.Version, packaging.version.LegacyVersion, str]
<class 'bool'>
typing.Union[packaging.version.Version, packaging.version.LegacyVersion]
<class 'str'>
~VersionTypeVar
<class 'bool'>
Specifier
typing.Union[packaging.version.Version, packaging.version.LegacyVersion]
<class 'str'>
SpecifierSet
<class 'str'>
<class 'packaging.specifiers._IndividualSpecifier'>
<class 'pipenv.vendor.pyparsing.ParseResults'>
typing.List[typing.Any]
<class 'packaging.markers.Node'>
typing.List[str]
typing.Tuple[packaging.markers.Node, ...]
<class 'str'>
typing.Dict[str, str]
typing.Dict[str, str]
<class 'NoneType'>
<class 'pipenv.vendor.tomli._parser.NestedDict'>
<class 'pipenv.vendor.tomli._parser.Flags'>
~V
~V
<class 'NoneType'>
<class 'bool'>
<class 'float'>
#
# These requirements were autogenerated by pipenv
# To regenerate from the project's Pipfile, run:
#
#    pipenv lock --requirements
#

<class 'str'>
<class 'pipenv.patched.notpip._internal.commands.CommandInfo'>
<class 'pipenv.patched.notpip._vendor.packaging.requirements.Requirement'>
typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version]
typing.List[pipenv.patched.notpip._vendor.packaging.requirements.Requirement]
NormalizedName
<class 'pipenv.patched.notpip._internal.operations.check.PackageDetails'>
NormalizedName
<class 'pipenv.patched.notpip._vendor.packaging.requirements.Requirement'>
NormalizedName
typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version]
<class 'pipenv.patched.notpip._vendor.packaging.requirements.Requirement'>
typing.Tuple[ForwardRef('NormalizedName'), pipenv.patched.notpip._vendor.packaging.requirements.Requirement]
NormalizedName
typing.List[typing.Tuple[ForwardRef('NormalizedName'), pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]
typing.Tuple[ForwardRef('NormalizedName'), typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version], pipenv.patched.notpip._vendor.packaging.requirements.Requirement]
NormalizedName
typing.List[typing.Tuple[ForwardRef('NormalizedName'), typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version], pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]
typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]]
typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version], pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]]
typing.Dict[ForwardRef('NormalizedName'), pipenv.patched.notpip._internal.operations.check.PackageDetails]
typing.Tuple[typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]], typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version], pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]]]
typing.Dict[ForwardRef('NormalizedName'), pipenv.patched.notpip._internal.operations.check.PackageDetails]
<class 'bool'>
<class 'bool'>
<class 'pipenv.patched.notpip._internal.req.req_install.InstallRequirement'>
typing.List[pipenv.patched.notpip._internal.req.req_install.InstallRequirement]
typing.List[pipenv.patched.notpip._internal.req.req_install.InstallRequirement]
typing.Tuple[typing.Dict[ForwardRef('NormalizedName'), pipenv.patched.notpip._internal.operations.check.PackageDetails], typing.Tuple[typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]], typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version], pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]]]]
typing.Tuple[typing.Dict[ForwardRef('NormalizedName'), pipenv.patched.notpip._internal.operations.check.PackageDetails], typing.Tuple[typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]], typing.Dict[ForwardRef('NormalizedName'), typing.List[typing.Tuple[ForwardRef('NormalizedName'), typing.Union[pipenv.patched.notpip._vendor.packaging.version.LegacyVersion, pipenv.patched.notpip._vendor.packaging.version.Version], pipenv.patched.notpip._vendor.packaging.requirements.Requirement]]]]]
<class 'NoneType'>
<class 'str'>
<class 'str'>
<class 'str'>
<class 'pipenv.patched.notpip._internal.metadata.base.BaseDistribution'>
<class 'pipenv.patched.notpip._internal.metadata.base.BaseDistribution'>
<class 'NoneType'>
